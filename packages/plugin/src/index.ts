import type {
  UnpluginFactory,
  TransformResult as UnTransformResult,
} from 'unplugin'
import type { Options } from './types'
import { createUnplugin } from 'unplugin'
import { generate } from 'valype'
import MagicString from 'magic-string'
import { readFile } from 'node:fs/promises'

/** regular expression match all virtual module generated by this plugin */
const virtualModuleRE = /^valype:/
// go's regex library doesn't support negative lookahead, so we use `[^v]` instead.
/** regular expression match all *.valype.ts written by user */
const valypeModuleRE = /^[^v].*\.valype\.ts$/

type TransformResult = Exclude<UnTransformResult, string>

export const unpluginFactory: UnpluginFactory<Options | undefined> = () => {
  // cache for generated schemas
  const schemaCache = new Map<string, string>()
  // cache for content of transformed `*.valype.ts` files
  const contentCache = new Map<string, TransformResult>()

  async function loadValypeFileContent(id: string): Promise<TransformResult> {
    if (contentCache.has(id)) {
      return contentCache.get(id)!
    }

    const code = await readFile(id, 'utf-8')
    const result = await generate(code)
    if (result.code && result.schemas.length > 0) {
      schemaCache.set(id, result.code)
      const s = new MagicString(code)
      s.prepend(`import { ${result.schemas.join(', ')} } from 'valype:${id}'\n`)
      s.append(
        `\n${result.schemas.map((schema) => `export { ${schema} }`).join('\n')}\n`,
      )
      const transformed: TransformResult = {
        code: s.toString(),
        map: s.generateMap({
          source: id,
          includeContent: true,
          hires: 'boundary',
        }),
      }
      contentCache.set(id, transformed)
      return transformed
    }
  }

  function loadVirtualModule(id: string): string | Error {
    const realId = id.slice('valype:'.length)
    const code = schemaCache.get(realId)
    if (!code) {
      return Error(`Cannot find schema for ${realId}`)
    }
    return code
  }

  return {
    name: 'unplugin-valype',
    resolveId: {
      filter: { id: virtualModuleRE },
      handler(id) {
        return id
      },
    },
    load: {
      filter: { id: [virtualModuleRE, valypeModuleRE] },
      async handler(id) {
        if (virtualModuleRE.test(id)) {
          const result = loadVirtualModule(id)
          if (result instanceof Error) {
            this.error(result.message)
          } else return result
        } else if (valypeModuleRE.test(id)) {
          return loadValypeFileContent(id)
        }
      },
    },
    // there is no need to use cache after build, so we can clear it to free memory
    buildEnd() {
      schemaCache.clear()
      contentCache.clear()
    },
    // vite use esbuild to optimize(pre-bundle) dependencies, in this process,
    // it will scan all dependencies used in source code,
    // but it doesn't use this plugin. So that it will not find schema generated by this plugin,
    // and report an error which says `No matching export in "src/*.valype.ts" for import "*Schema"`.
    // Therefore, we need to add a plugin to esbuild to handle `*.valype.ts` files.
    vite: {
      config() {
        return {
          optimizeDeps: {
            esbuildOptions: {
              plugins: [
                {
                  name: 'unplugin-valype/deps-optimization',
                  setup(build) {
                    build.onLoad({ filter: valypeModuleRE }, async (args) => {
                      const result = await loadValypeFileContent(args.path)
                      if (result) {
                        return {
                          contents: result.code,
                          loader: 'ts',
                        }
                      }
                    })
                    build.onResolve({ filter: virtualModuleRE }, (args) => {
                      return { path: args.path, namespace: 'ts' }
                    })
                    build.onLoad({ filter: virtualModuleRE }, async (args) => {
                      const code = loadVirtualModule(args.path)
                      if (code instanceof Error) throw code
                      return {
                        contents: code,
                        loader: 'ts',
                      }
                    })
                  },
                },
              ],
            },
          },
        }
      },
    },
  }
}

export const unplugin = /* #__PURE__ */ createUnplugin(unpluginFactory)

export default unplugin
